# 数据库
1.	数据库类型
常用的关系型数据库：商业数据库（oracle，sqlserver更适合企业级项目），开源数据库（mysql 、pgsql适用于互联网项目），dbll，sybase
非关系型数据库：mongodb，redis，memcach，hbase，neo4j
2.	数据库事务
数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。
并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。
	原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
	一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。当事务完成时，数据必须处于一致状态。
	隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
	持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。
	
3.	数据库设计
1、需求分析：数据是什么；数据有哪些属性；数据和属性各自的特点有哪些；
2、逻辑设计：使用er图对数据库进行逻辑建模；
3、物理设计：根据数据库自身的特点把逻辑模型转换为物理设计；
4、维护优化：新的需求进行建表，索引优化，大表拆分。
1.	为什么要进行需求分析：
了解系统总所要存储的数据，数据的存储特点，数据的生命周期
实体及实体之间的关系（1对1，1对多，多对多）
实体包含的属性有哪些？
哪些属性或属性的组合可以唯一标识一个实体？
 
2.	物理设计要做什么
1、选择适合的数据库管理系统；2、定义数据库、表及字段的命名规范；3、根据所选的DBMS系统选择合适的字段类型；4、反范式化设计。
4.	名词解释：
关系：一个关系对应通常所说的一张表；
元组：表中的一行；
属性：表中的一列即为一个属性，每个属性都有一个名称，称为属性名；
候选码：表中的某个属性组，它可以唯一确定一个元组；
主码：一个关系有多个侯选码，选定其中一个为主码；
域：属性的取值范围；
分量：元组中的一个属性值。

码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。
主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。
非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。

 

 

5.	函数依赖
部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。 
举个例子：学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）； 

完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。 
例子：学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；

传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。 
例子：在关系R(学号 ,宿舍, 费用)中，(学号)->(宿舍),宿舍！=学号，(宿舍)->(费用),费用!=宿舍，所以符合传递函数的要求；

6.	设计范式
第一范式1NF：
数据库中的所有字段都是单一属性，不可再分的。這个单一属性是由基本的数据类型所构成的，如整数，浮点数，字符串等；换句话说，第一范式要求数据库中的表都是二维表（行列组成的表）。
第二范式2NF：
第二范式建立在第一范式的基础上，即满足第二范式一定满足第一范式，第二范式要求数据表每一个实例或者行必须被唯一标识。除满足第一范式外还有两个条件，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。
举例来说：当数据表中是联合主键，但是有的列只依赖联合主键中的一个或一部分属性组成的联合主键，此时需要拆表才能复合第二范式。
3NF 
若某一范式是第二范式，且每一个非主属性都不传递依赖于该范式的候选键，则称为第三范式，即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
举例来说：Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)，当员工表中emp_id能够唯一确定员工员工信息，但是dept_name可由dept_id唯一确定，此时，该表不符合第三范式，此时可以删除除了dept_id之外的其他部门信息，把所有部门信息单独建立一张部门表。
总结：
第一范式：简单说 列不能再分
第二范式：简单说 建立在第一范式基础上，消除部分依赖
第三范式：简单说 建立在第二范式基础上，消除传递依赖。
BCNF
 在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式。
也就是说如果是复合关键字，则复合关键字之间也不能存在函数依赖关系。
（1）所有非主属性对每一个码都是完全函数依赖； 
（2）所有的主属性对于每一个不包含它的码，也是完全函数依赖； 
（3）没有任何属性完全函数依赖于非码的任意一个组合。
R属于3NF，不一定属于BCNF，如果R属于BCNF，一定属于3NF
假设仓库管理关系表(仓库号，存储物品号，管理员号，数量)，满足一个管理员只在一个仓库工作；一个仓库可以存储多种物品，则存在如下关系：
(仓库号，存储物品号)——>(管理员号，数量)
(管理员号，存储物品号)——>(仓库号，数量)
所以，(仓库号，存储物品号)和(管理员号，存储物品号)都是仓库管理关系表的候选码，表中唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：
(仓库号)——>(管理员号)
(管理员号)——>(仓库号)
即存在关键字段决定关键字段的情况，因此其不符合BCNF。把仓库管理关系表分解为两个关系表仓库管理表(仓库号，管理员号)和仓库表(仓库号，存储物品号，数量)，这样这个数据库表是符合BCNF的，并消除了删除异常、插入异常和更新异常。
7.	创建和删除自定义函数语法:
创建UDF:
　　CREATE [AGGREGATE] FUNCTION function_name(parameter_name type,[parameter_name type,...])
　　RETURNS {STRING|INTEGER|REAL}
　　runtime_body
简单来说就是:
　　CREATE FUNCTION 函数名称(参数列表)
　　RETURNS 返回值类型
　　函数体
删除UDF:
　　DROP FUNCTION function_name
调用自定义函数语法:
　　SELECT function_name(parameter_value,...)
语法示例:
创建简单的无参UDF
CREATE FUNCTION simpleFun()RETURNS VARVHAR(20) RETURN "Hello World!";
说明:
UDF可以实现的功能不止于此,UDF有两个关键点,一个是参数,一个是返回值,UDF可以没有参数,但UDF必须有且只有一个返回值
在函数体重我们可以使用更为复杂的语法,比如复合结构/流程控制/任何SQL语句/定义变量等等
复合结构定义语法:
在函数体中,如果包含多条语句,我们需要把多条语句放到BEGIN...END语句块中
DELIMITER //CREATE FUNCTION IF EXIST deleteById(uid SMALLINT UNSIGNED)  RETURNS VARCHAR(20)BEGINDELETE FROM son WHERE id = uid; RETURN (SELECT COUNT(id) FROM son); END//
修改默认的结束符语法:
DELIMITER // 意思是修改默认的结束符";"为"//",以后的SQL语句都要以"//"作为结尾
特别说明:
UDF中,REURN语句也包含在BEGIN...END中
自定义函数中定义局部变量语法:
declare var_name[,varname]...date_type [DEFAULT VALUE];
简单来说就是:
DECLARE 变量1[,变量2,... ]变量类型 [DEFAULT 默认值]
这些变量的作用范围是在BEGIN...END程序中,而且定义局部变量语句必须在BEGIN...END的第一行定义
DELIMITER //CREATE FUNCTION addTwoNumber(x SMALLINT UNSIGNED, Y SMALLINT UNSIGNED)  RETURNS SMALLINTBEGINDECLARE a, b SMALLINT UNSIGNED DEFAULT 10; SET  a = x, b = y; RETURN a+b;END//上边的代码只是把两个数相加,当然,没有必要这么写,只是说明局部变量的用法,还是要说明下:这些局部变量的作用范围是在BEGIN...END程序中。
为变量赋值语法:
SET parameter_name = value[,parameter_name = value...]
SELECT INTO parameter_name
eg: 
...在某个UDF中...DECLARE x int;SELECT COUNT(id) FROM tdb_name INTO x; RETURN x; END//
用户变量定义语法:(可以理解成全局变量)
SET @param_name = value
SET @allParam = 100;SELECT @allParam;
上述定义并显示@allParam用户变量,其作用域只为当前用户的客户端有效
8.	Mysql常用的存储引擎
 

InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page， page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。
适用场景：
1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过 bin-log 日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性 auto_increment。

9.	什么是反范式化
反范式化是针对范式化而言的，在前面介绍了数据库设计的第三范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对第三范式进行违反，而允许存在少量的数据冗余，换句话来说反范式化就是使用空间来换取时间。
1、	减少表的关联数量；2、增加数据的读取效率；3、反范式化要适度。

10.	数据库如何维护数据字典
1、使用第三方工具对数据字典进行维护
2、利用数据库本身的备注字段来维护数据字典，如MySQL 给库、表、字段增加备注，然后导出数据字典，
   

11.	如何维护索引
如何选择合适的列建立索引？
1、	出现在where从句，group by从句，order by从句中的列；
2、	可选择性高的列要放到索引的前面；
3、	索引中不要包括太长的数据类型。
注意事项：
1、	索引并不是越多越好，过多的索引不但会降低写效率而且会降低读的效率
2、	定期维护索引碎片
3、	在SQL语句中不要使用强制索引关键字

12.	数据仓库的特点
•	主题性：数据仓库是针对某个主题来进行组织，比如滴滴出行，司机行为分析就是一个主题，所以可以将多种不同的数据源进行整合。而传统的数据库主要针对某个项目而言，数据相对分散和孤立。
•	集成性：
数据仓库需要将多个数据源的数据存到一起，但是这些数据以前的存储方式不同，所以需要经过抽取、清洗、转换的过程
•	稳定性：保存的数据是一系列历史快照，不允许修改，只能分析。
•	时变性：会定期接收到新的数据，反应出最新的数据变化。
总的来说，数据仓库是将多个数据源的数据按照一定的主题集成起来，因为之前的数据各不相同，所以需要抽取、清洗、转换。
整合以后的数据不允许随便修改，只能分析，还需要定期更新。
ETL
上面我们说过，数据仓库接收的数据源是不同的，要做集成的话，需要抽取、清洗、转换三个步骤，这就是ETL(Extract-Transform-Load)
•	Extract：数据抽取，就是把数据从数据源读出来
•	Transform：数据转换，就是把数据转换为特定的格式
•	Load：数据加载，把处理后的数据加载到目标处。
国内最常用的是一款基于Hadoop的开源数据仓库，名为Hive，它可以对存储在HDFS的文件数据进行查询、分析。
13.	数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。 
操作型处理，叫联机事务处理OLTP（On-Line Transaction Processing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发的支持用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。
分析型处理，叫联机分析处理OLAP（On-Line Analytical Processing）一般针对某些主题历史数据进行分析，支持管理决策。 

